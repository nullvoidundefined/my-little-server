import "dotenv/config";
import path from "node:path";
import { fileURLToPath } from "node:url";

import cookieParser from "cookie-parser";
import express from "express";
import helmet from "helmet";

import { corsConfig } from "app/config/corsConfig.js";
import pool, { query } from "app/db/pool.js";
import { csrfGuard } from "app/middleware/csrfGuard.js";
import { errorHandler } from "app/middleware/errorHandler.js";
import { notFoundHandler } from "app/middleware/notFoundHandler.js";
import { rateLimiter } from "app/middleware/rateLimiter.js";
import { requestLogger } from "app/middleware/requestLogger.js";
import { loadSession, requireAuth } from "app/middleware/requireAuth.js";
import { authRouter } from "app/routes/auth.js";
import { jobsRouter } from "app/routes/jobs.js";
import { recruitersRouter } from "app/routes/recruiters.js";
import { recruitingFirmsRouter } from "app/routes/recruitingFirms.js";
import { logger } from "app/utils/logs/logger.js";

function validateEnv(): void {
  if (!process.env.DATABASE_URL) {
    console.error("Fatal: DATABASE_URL is required");
    process.exit(1);
  }
  if (process.env.NODE_ENV === "production" && !process.env.CORS_ORIGIN) {
    console.error("Fatal: CORS_ORIGIN is required in production");
    process.exit(1);
  }
}

const app = express();
const REQUEST_TIMEOUT_MS = 30_000;

// Add security-related HTTP headers to reduce common web vulnerabilities (XSS, clickjacking, MIME sniffing, etc.).
app.use(helmet());

// Allow browser frontends to call this API while still controlling which origins are permitted.
app.use(corsConfig);

// Attach structured request/response logging (with request IDs) early so all downstream handlers are observable.
app.use(requestLogger);

// Apply a basic rate limiter to protect the API from simple abuse and accidental client floods.
app.use(rateLimiter);

// Parse JSON request bodies and cap payload size to avoid unexpectedly large requests.
app.use(express.json({ limit: "10kb" }));

// Parse URL-encoded form submissions (e.g. HTML forms) with the same size cap as JSON.
app.use(express.urlencoded({ extended: true, limit: "10kb" }));

app.use(cookieParser());

// Require X-Requested-With on state-changing requests to mitigate CSRF.
app.use(csrfGuard);

// Load session from cookie and set req.user when valid (does not block unauthenticated requests).
app.use(loadSession);

// Timeout long-running requests so hung connections don't stay open indefinitely.
app.use((_req, res, next) => {
  res.setTimeout(REQUEST_TIMEOUT_MS, () => {
    if (!res.headersSent) {
      res.status(408).json({ error: { message: "Request timeout" } });
    }
  });
  next();
});

query("SELECT NOW()")
  .then(() => logger.info("Connected to database"))
  .catch((err: unknown) => logger.error({ err }, "Database connection failed"));

app.get("/health", async (_req, res) => {
  try {
    await query("SELECT 1");
    res.status(200).json({ status: "ok", db: "connected" });
  } catch {
    res.status(503).json({ status: "degraded", db: "disconnected" });
  }
});

app.use("/auth", authRouter);

app.use("/jobs", requireAuth, jobsRouter);
app.use("/recruiters", requireAuth, recruitersRouter);
app.use("/recruiting-firms", requireAuth, recruitingFirmsRouter);

// Attach reusable utilities for 404 and error handling.
app.use(notFoundHandler);
app.use(errorHandler);

const PORT = process.env.PORT ?? 3000;

const entryPath = process.argv[1];
const isEntryModule =
  entryPath !== undefined &&
  path.resolve(entryPath) === path.resolve(fileURLToPath(import.meta.url));

if (isEntryModule) {
  validateEnv();
  const server = app.listen(PORT, () => logger.info({ port: PORT }, "Server running"));

  async function shutdown(signal: string) {
    logger.info({ signal }, "Shutting down gracefully");
    await new Promise<void>((resolve) => server.close(() => resolve()));
    logger.info("HTTP server closed");
    await pool.end();
    process.exit(0);
  }

  process.on("SIGTERM", () => shutdown("SIGTERM"));
  process.on("SIGINT", () => shutdown("SIGINT"));
}
